
##　基本方針

歴史的な経過についてはページは多く割かない。
なぜその選択肢を選んだのかについて出来るだけ客観的に解説する。
ルールと戦術の区別は、はっきりわかるようにする。

○はじめに

1974年、インテルが世界初のマイクロプロセッサ8080を発売しました。

今日、一般に人々が目にするアプリケーションは、スマートフォン用の物が多く、「アプリケーション」がPCネイティブ用に作られた物を指していう場面はあまり多くなくなりました。



その後インターネットの普及に伴って

インテルが世界初のマイクロプロセッサと言える８０８０を発表してから
過去との互換性のために存在する技術

一人の技術者が全体を把握できるサイズのマイクロコンピュータシステム
教育用

最初にコンピューターの基本的な動作原理
プロセッサQV80の内部から外部に向かって解説を広げていく。


プロセッサ、周辺機器、コンパイラ、OS、最小限のアプリケーション
すべてオープンソース

用語の定義は現在のものを反映していないかもしれない
独自用語もある
用語解説は別項で
　歴史的な経緯も含めて別に解説

加算は得意だとか、減算は苦手とかやめよう。

○はじめに
　私たちが日ごろから利用しているコンピュータと言われるモノについて、中身はどうなっているんだろう？という興味を持つってコンピュータの仕組みについて検索すると、マザーボードにCPUとメモリが乗っていてディスクインターフェイスがあって、という絵に出合うでしょう。もう少し調べて、コンピュータは二進数で「計算」しているとか、各装置に指令を出しているとか、どうしても擬人化した表現になります。
　では、CPUの中身は実際どういう原理で動作しているのでしょう。それについて深く調べていくと、基本ゲート、つまりNOT、AND、ORの3つから出来ていて…という解説に行き当たります。
　ところが、このゲートの話と、CPUやメモリやハードディスクの話の間のつながりは、なかなか出てきません。CPUは引き算が苦手とかCPUはどうやって「判定」しているのか、とか、やはり擬人化の壁に阻まれます。
　おそらく書いている人も理解していないせいでしょう。

　その昔まだコンピュータがマイコンと呼ばれていた時代から基本的な動作原理は全く変っていません。
　コンピュータは計算とか判定とか一切していません。コンピュータはただ単に**スイッチのON/OFFの連鎖**で動作しています。
　では、連鎖の始まりはどこから来るのでしょう？
　その代表的な例がキーボードです。あなたがキーを押します。するとキーには接点があって、キーボードの中の配線のうちのどれかがつながります。例えばこれは片方はコンピュータに、もう片方は電源につながっていて、キーを押したときだけ電気が流れるようになっています。
　コンピュータの中ではこの電気の流れでスイッチの連鎖に変化がおこります。電気の流れに変化があるとソフトウエアの処理に変化がおこります。そうしてあなたが見ている画面に文字が出てくるまでの一連の連鎖となります。
　スイッチのON/OFFだけのコンピュータで、ブラウザや動画再生など何かしているように見えるのは、その連鎖の途中にソフトウエアがあるからで、ソフトウエアの演出に過ぎないのです。そして、そのソフトウエアも、スイッチの連鎖の伝わり方を変える事しか出来ません。

　本サイトでは、トランジスタの動作からコンピュータの動作までをミッシングリンクの無いように解説し、8ビットCPUを手作りし、最後はそれにシングルタスクOSとコンパイラを乗せて、マイコン黎明期のコンピュータを作ります。

・なぜ今8ビットなのか
　性能を上げる工夫が少ないので、プリミティブな部分の占める割合が多い。
　そのため、見渡しがよい。とても。

　一息ついたらパイプライン、アウトオブオーダー、キャッシュ、マルチコアなんか広げて行きたい。



○０章
　コンピュータ登場

　数学的裏づけ

　クロードシャノンとジョージブール
　アランチューリング
　　【第２話】チューリング・マシンで示された計算の原理と限界　https://note.com/fujitahajime/n/nfddcf5965dad
　　ウルフラムの2状態3記号チューリングマシン
　フォンノイマン
　ウォルフラム
　　2状態3要素チューリングマシン証明
　　https://blog.wolfram.com/2007/10/24/the-prize-is-won-the-simplest-universal-turing-machine-is-proved/?year=2007&monthnum=10

　プッシュダウン・オートマトン

　非決定性有限オートマトン
　　非決定性と呼ばれるのは、ある状態からの遷移先が入力文字だけでは一意に定まらない場合があることと、入力文字を受け取らなくても状態遷移する場合があることからである。例えば、状態 S1 にあって文字 a が入力された場合、この文字を受け取らずに状態 S2 に遷移してから a を受け取って状態 S3 に遷移することが可能である。

　フリップフロップ
　真空管マシン
　ゲートロジック
　i8080の登場

○１章
　プロセッサ基礎

・計算機について

.トランジスタ
.デジタルとアナログ
.ゲート
.セレクタ
.減算器
.フリップフロップとクロック


.メモリ
　ROM/RWM
　シーケンシャルに対してランダム

　Read Only Memory 計算機実行時に書き込みが出来ないメモリ

　ROMの現在の定義
　インシステムプログラミングを含め、書き込み時、実行時に特別な手順を必要とするもの。
　システムの動作を停止し、他の方法で書き込む必要のあるもの。
　　停止は電源を落とすとは限らない。例えばリブート時に特定のピンの状態でプログラムモードに突入するデバイスがある。

　RAMの現在の定義
　SRAM、DRAMは商品名の一部になっている。
　MRAM、FRAMなど、電源を落としても状態を保持するものがある。
　一般にシステム駆動時に内容の書き換えが可能、または書き換えを前提にしているものをRAMと呼ぶ。

　SRAMのインターフェイス
　　アドレス、データバス
　　CS、RD、WR

　インターフェイス
　シリアル、パラレルどちらも存在する。

　SRAM、DRAM
　トランジスタ数、リフレッシュ処理が必要かどうか
　リフレッシュの不要なメモリ素子をDRAMインターフェイスに合わせたもの。
　DRAMのリフレッシュ回路まで組み込んで、外部とのインターフェイスはパラレル非同期SRAMに合わせたPSRAM。


・ノイマンモデル
　きちんと調べてあげたい。英語の論文は読めないので和訳を探す

・ISAの選定


演算。移動は広義の演算と考える
　１オペランド
　　１つでいい命令、NOT、NEGなど

　２オペランド

　distを含む＋１オペランド命令
　比較と分岐先アドレスを含む３オペランド

フロー制御

アドレッシングモード

その他


○CPU2908の構造


・プロセッサの動作


・8085の例

・6809の例


・bool代数

.論理和、論理積
　AかBといえば、どちらか一方だが、論理和は両方の場合もある。

.クワイン・マクラスキー法
　クワイン・マクラスキー法の解説の後で、手作業で行うカルノー図という手法があるという説明
.カルノー図


○CPU2908：概要

・ピンファンクション

.電源
..Vss　グランド
　0Vの電位である
..Vdd　電源
　動作に必要な電源と、各信号線

○外部信号

・バス
　アドレス
　　CEはアドレスデコーダが作る
　データ
　RD
　WR

・コントロールシグナル

・割り込み

・DMA
　　DMAは

○内部動作


・インストラクション


・I/O
　ポーリング、割り込み、タスク


○周辺チップ
・リセット、WAITコントローラ


・バンクコントローラ
　上位32Kを4Kごとに分けて256バンク。
　最上位4kはI/O空間なので、

RTC
割り込みコントローラ

シリアルコントローラ
パラレルインターフェイス

DMAコントローラ

メモリコントロール
　アドレスとデータ、CE、RD、WRの3つの基本制御線

USB

	ハードウエアではCRCの計算、1.5M転送、ビットスタッフを行う

Ethernet
ビデオカード
　キャラクター表示のみ
グラフィックカード
　ビットマップを扱える


○周辺機器




○TKQ8
・搭載している周辺機器
・ブートローダー


○開発環境
・フルアセンブラのcc500移植版
・ANJI-Cの移植

○OS

・電気の話

電圧は負荷の両端に発生する
　電池計ったら1.5Vでしょ

電圧と負荷が決まれば、電流はイヤでも流れる。


出力は必ずしも電流の向きとは限らない。


スイッチの連鎖

最初のスイッチは？
　たとえばあなたがキーボードのキーを押した／押してない


真空管
　金属を熱して電子を飛び出させる
　途中にスイッチになる網を置いておく
　網に電圧を掛けると、飛び出した電子が向こう側に行けなくなる
　　スイッチ

リレー
　電磁石と普通の磁石、電磁石に電気流すと電極が引っ張られて電気が通らなくなる
　　スイッチ

コンピュータはスイッチで別のスイッチを制御して、それがずっと向こうまで伝わっていく構造。


コンピュータは引き算
　引けない時上の桁から借りてくるー>borrow


・セレクタ

加算器は減算器にちょっと手を加えれば作れる事をしめしました。
加算と減算の違いは入力の片方を０から引いた数に置き換えるかどうかです。
そこで、減算器として動作するのか、加算器として動作するのかの入力を増やして、全体では１つの回路で加算と減算のどちらかを選べる回路にしていこうと思います。

そこで、２つのうちのどちらかを選ぶ回路、です。



・合わせてみた


・繰り上がりを表現したい

引き算回路なのでu=1の時そのまま、u=0の時は結果から1減る回路です。
足し算なので、繰り上がりを計算したいので、uの機能を u=0の時0を足して、u=1の時に1を足す、というふうに変えたいです。
　u=0 の時 0 を足す
　u=1 の時 1 を足す
にしたいわけです。

ということは、引き算の時は u=0 で1を u=1 で0を引いていたこの回路を、足し算の時には A-(0-B)+u にする事になります。
ここで、式を変形して A-(0-B-1) にしましょう、この回路は引き算回路なので、足し算にするには以下略

そうすると、丁度０から引く回路があるので、そっちのu（ADD_Tempのu2ですね）を0にすれば、さらに１を足す回路の代わりになります。
ここまでおけ？

なので、０から引く回路のuを0にします。

u2が０固定になるそうすると、0から引く回路が、Bをただ反転する回路になります。
やってみたください。

結果はADD_Fixedです、すっきりしましたね。


・決めること
コンピュータの設計はその殆どが動作を決める事で成り立っている。

コンピュータの動作原理の説明で、コンピュータは減算が出来ないとか苦手とか書いてある解説を幾つもみた。けど、減算が苦手とか、そんな。こたぁ無いんですよ。
大事なのは「どういうふうに動作するのか決める」事。
今回の減算器も「最初に上の桁から借りてくるための１を用意する」って決めて作り始めました。
そして、入力と出力の組み合わせを決めて、そこから回路を作り起したよ。

だから、最初に決めたやりかたで操作する減算器と、それを利用した加算器


何が入ってきたらどうする、は、設計する人が決める事。


「これは引き算回路」って思っているのは設計した私です。
そもそも

・ラーメンタイマーへの道

今更ですが、コンピュータの動作原理について理解する時、まず最初にココロノジュンビが必要です。
コンピュータは、誰かが「こういう時はこういう結果」って決めて設計したモノの集合です。

「コンピュータは減算が苦手」とか書いてあるサイト見たことがあります。
とんでもないです。

これまでにいくつか真理値表を書いてゲートを使った回路を設計しました。
それがコンピュータに出来る事のほぼ全てです。

１と０の組み合わせだけの真理値表では表現が難しいものもあります。
たとえば、これから解説する「０から１に変わった時だけ出力が変化する」タイプの動作であるとか、真理値表の出力に Don't care（何でもおけ）や Hi-Z（ハイインピーダンス、電源にもグランドにもつながってない状態）であるとか。
でもそれらの回路は実際に作って動作させれば、なにかしらの電気的状態になる、っていうのは変わらないんですよ。

「CPUの創りかた」という本があって４ビットCPUをICをハンダ付けして手作りしよう、という趣旨です。
その本は最終的にラーメンタイマー（３分計）を実行する事を目標にしています。

なので、ラーメンタイマー作ってみましょう。

用意するもの
・Logisim　このソフト上でシミュレーションします
・減算／加算器　今回は２つ登場してもらいます
・ラッチ　次で解説します

機能は
・スイッチを押して３分経ったら何かでそれを知らせる
です。


ICをたったの11個で！みたいなウリですが、加算器使ってるのでICの数にはあまり意味がないでしょう。
P8X32A{http://akizukidenshi.com/catalog/g/gI-06803/}を使って「ICたったの1個でコンピュータ！！」っていうのもいけちゃうし。

ところで、「CPUの創りかた」は、最終的にラーメンタイマー（３分計）が動作するのを見て終わりになります。
そこで、次の課題はラーメンタイマー（３分計）にしてみましょう。



・ラーメンタイマー１
実際の回路では、GPSからもらった１秒毎の信号で１と０が反転する回路を組むのがいいでしょう。
で、周波数は0.5Hzにします。
最初は３分計を作りますが、５分と切り替えられたらうれしいなあ、でも減算／加算器は８ビットで１０進数だと０～２５５までしか数えられません。
なので、２秒で１カウントとして、５分計の時の１５０カウントまで対応します。

・ラッチとかフリップフロップ

※この記事は寄り道なので、読み飛ばしてもええです。

セレクタにフィードバックする
Ｓが１の時ＹがＡと同じになり、Ｓが０の時はＡに関係なくＹがそのままです。
これはＡが０の時にはうまく動作するし、Ａが１でＳを１にした時も動作します。
しかし、Ａが１のままＳを１→０にした時に困ったことになります。

スイッチの切り替えは少し時間がかかるのです。

Ｓが０になった瞬間
・Ｄへの入力の片方が０になるので２の出力が０
・Ｅは入力が両方０になったので出力が０
と同時に
・Ｃは入力が両方１になるので出力が１
・Ｅは片方の入力が１になったので出力が１
矛盾が生じます。
スイッチの切り替えは少し時間がかかるので、ＮＯＴゲートがある分だけ、Ｓ→ＣよりＳ→Ｄの方が一瞬早くＥに伝わります。
けど、Ｃの入力が両方１になった時にはまだＥの出力が切り替わってなくて１です。
こうして↑２つの状態がすごい勢いで切り替わる事になります。
「発振」と呼ばれている現象です。

・修正版

Selector-Feedbackをみてください。
一番上
ＯＲを２つに増やして（Ｆ、Ｇ）、ＦにＧの出力を一時受け取っておいてもらいます。

２つめ
ＯＲはそのままだと筒抜けで発振の原因になります。なのでＮＯＴを入れて預ける時に反転して、返してもらう時にもう一度反転します。
セレクタの機能は必要ないので、そこは削除です。
出力を反転するようにしちゃったので、Ａの入力も反転します。

３つめ
このままだとＧの出力が１になった時、Ｆの出力が０、反転して１になるので、Ｇを変える事が出来なくなります。
ＡとＳからＦとＧをコントロールするのですから、Ｆの入力もＳとＡから作ります。
ＳとＡ→Ｇの回路と同じものをつなげますが、ＦとＧは状態が反転しているので、Ａからの入力をさらに反転します。

これで、一時的にとっておいてくれる回路が出来上がりました。


・使いやすさと安全と

引き続き RamenTimer.circ です。

Selector-Feedback（じゃないけどな、既に）はＳが１の時にＡを出力して、Ｓが０の時はＡが変わっても出力が変わらない回路です。
けれど、Ｓが１の間にＡが変わったら、それが筒抜けになります。
今回は時間を計るのに１秒毎に１と０が切り替わるやつを使います、という事はＳが１の間に加算器が結果を出してくれちゃったら、それが出力に出ちゃうわけです。
どうするかというと、Selector-Feedbackを二段にして、片方はＳが０の時に出力を変化させ、２段目はＳが１の時に出力を変化させるように作ります。
そうすると、Ｓが０→１と変わった時にだけ、出力が変化する回路になります。
名付けて Selector-Feedback-Double-Staged 略して FSB-DS です。
ついでに、リセットスイッチ付けときます。
これでラーメンタイマーに必要なモノが揃いました。


チャタリング醜いけどこんなんファームっでｄなんとかっしないとだろ



○PC-2908

・FPGA版

BIOS-ROM
.ORG $100
SPI
TxChar
RxChar
SPI-RAMコピー
ROM・RAMメモリ切り替え



今回、減算器は、

#rAB Y(A-B) r
000 10
001 00
010 01
011 10
100 01
101 10
110 11
111 01


OP	u	A	B	Y	r

0	0	0	0	0	0
0	0	0	1	1	0
0	0	1	0	1	0
0	0	1	1	0	1
0	1	0	0	1	0
0	1	0	1	0	1
0	1	1	0	0	1
0	1	1	1	1	1

1	0	0	0	1	0
1	0	0	1	0	0
1	0	1	0	0	1
1	0	1	1	1	0
1	1	0	0	0	1
1	1	0	1	1	0
1	1	1	0	1	1
1	1	1	1	0	1



・入力と出力
電流の向きとは関係なく機能から入力と出力と言う。


最上桁より１こ上 1-下の桁

00-11
100から11引いて01 borrow

＝をつかわないわけ

もうすこし回路らしく
　電池とLEDをつないでスイッチで切り替える回路


・並列と直列

便利な回路ANDとOR

AND	どっちも１の時。

OR

NOT

A Y
0 1
1 0

OR
AB Y
00 0
01 1
10 1
11 1

NOR
AB Y
00 1
01 0
10 0
11 0

AND
AB Y
00 0
01 0
10 0
11 1

NAND
AB Y
00 1
01 1
10 1
11 0

NOT AND OR



XOR
AB Y
00 0
01 1
10 1
11 0

(~A & B) | (A & ~B)

・多入力AND、OR


・電池の＋－

・電圧とFET
　Nｃｈはなぜハイサイドに使えないのか。



・記号とか表記について






・OS-Q
　プリエンプティブなマルチタスク、マルチスレッド。
　マルチユーザー

・プリエンプティブなマルチタスク

・ユーザー

・デバイス

・ライブラリ
　OSQではライブラリはダイナミックがデフォルト



・On/Off　cmos　電圧の話


・リソース

・VRAM
・ウィンドウマネージャ


○用語解説
・プロセッサ
・RAM



○QV00実験プロセッサ



○QV00インストラクション
e:\projects\qv08\documents\qv00_instruction.txt

・ExecuteSignalControl

fetch addr-out
CP/SP::	InSelect=00
		OpSelect=10
		CPLatch=0
		SPLatch=0
		OutSelect=0
		OutEnable=0
DataREG


stage+next stage+datapath ctrl

addrout-datain
addrout-dataout
decode

fetch
 CP->addrout-datain

ld
　addrout-datain
st
mov
movi
1op
2op
push
 dec sp
 addrout-dataout

pop
 addrout-datain-datareglo
 inc-sp
 addrout-datain-datareg-hi
 inc-sp
 data-reg

jmp
 cond
 lo-in
 hi-in

call
 lo-in
 hi-in


ALU_Selector
A B C SA PO1 PO2 CY
-------------------
0 0 0  0 0 0 0 # add
0 0 1  1 0 0 0 # sub
0 1 0  x 0 1 x # and
0 1 1  x 1 0 x # or
1 0 0  x 1 1 0 # not
1 0 1  x 1 1 1 # sar

SA Sub/Add
OP1:OP2
 00 sub/add
 01 and
 10 or
 11 not/shift
CY NOT/SHIFT CarrySelect


・INC/DEC SP/CP
---
　CPインクリメントが回路の主な目的
　CP、SP、入力のインクリメント／デクリメント、直接出力、０入力、反転の機能がある。

使い道
---
OPTranslate
0000 CPインクリメント	内部でラッチする、出力は現在のCP
0001 IN→CP
0010 SPインクリメント		インクリメントした値をそのまま出す　SPはラッチするが、出力はインクリメント後（CPと違う）
0011 SPデクリメント			デクリメントした値をそのまま出す
0100 IN→OUT
0101 IN→SP
0110 INインクリメント->TEMPにラッチ
0111 INデクリメント
1000
1001 CP->OUT
1010
1011
1100 TEMP->OUT
1101 SP->OUT
1110
1111
in
InDataLo	入力上位バイト
InDataHi	入力上位バイト

InSelect	２ビット　０：CP　１：SP　２：InData　３：０
OPSelect	２ビット　０：INC　１：DEC　２：Through　３：反転
CPLatch		１：次のクロックでCPラッチ
SPLatch		１：次のクロックでSPラッチ
OutSelect	２ビット　出力選択　０：CP　１：SP　２：OP計算済み　３：入力する～

OutEnable

CLK
Reset

out
OutLo	出力下位バイト
OutHi	出力上位バイト
　データバスにつなぐので。


○ DataRegister
---
　R0-R3の４本の８ビットレジスタ
　入力が８ビット２本、出力も８ビット２本
　それぞれDataBusのLoとHiにつながっている
　ALUの出力はLo側に入れてある
　が、中でクロススイッチできるので、HiとかLoとかあんまり関係ない。
　アドレスはHiとLoが区別されているので、それに合わせて出力。

使い道
---

DataRegisterCtrl


0110 000r push wr
0110 100r pop wr

000 0 0wrr LD r,[w]
000 0 1wrr ST [w],r

000 1 00rr MOVI r,imm8

001 1000r INC w ; inc word reg
001 1010r DEC w ; dec word reg

010 0 ddss mov r,r
010 1 ddss movw r,r dd,ss=SP,CP含む2bit


・Disabble
000

・W InternalDataBus in/out
110
MOVW SP|CP,W0|W1
INC,DEC,PUSH
	W0,W1 -> InternalDataBus

・MOVW W0|W1,SP|CP
111
INC,DEC,POP
		W0,W1 <- InternalDataBus

・mov byte
001
	Rsrc→Rdst IndataSelect,WriteSelect,Outselect12,Outenable12

　OutEnable2←Disable
　OutEnable1<-Enable
　DregWriteSelect
　DRegOutSelect1 Rsrc

・movw W0,W1|W1,W0
010

・mov R->ALU->R
　Src,DistをALUに出力、ALUは独自バスなので、ALU出力をそのまま入力に出来る。

・mov DataBus→R0-R3(W0-W1)
100

・mov R0-R3<-DataBus(W0-W1)
 ST,MOVI,POP
101


・TransrateROM
レジスタセレクタ
＊mov r,r（バイト）は入力出力とも2bitで、これをセレクタに使うけど、LD,STはWがbit2なので、これを出力レジスタセレクタに使うBIT:1
＊下位２ビットがソースで次の２ビットがdestでありゅBIT：１　そうでなければ0
下位２ビットがdistかsrcかビット：１
次の２ビットがdistかsrcビット：１
最下位下位１ビットがWかビット：１
の３ビット

バスに出すか、バスからもらうか
両方立ってたらmov

・RegInState
r0,r1,r2,r3,w0,w1の６通り＋NOP
S0	S1	S2	O0	O1	O2	O3
0	0	0	0	0	0	0
0	0	1	0	0	0	0
0	1	0	1	0	0	0
0	1	1	0	1	0	0
1	0	0	0	0	1	0
1	0	1	0	0	0	1
1	1	0	1	1	0	0
1	1	1	0	0	1	1
Hi->Rは無いので。

・RegOutState
Inと違ってr0-r3のどれもLoHiに出す場合がある
r0-r3　それぞれ Hi/Lo どちらに出すか
DatRegOutLo:2 Loにどのレジスタを出すか
DatRegOutHi:2 Hiにどのレジスタを出すか
DatRegOutEnableLo:1 Loの出力をEnabるか
DatRegOutEnableHi:1 Hiの出力をEnabるか


W out	Lo:Hi 00:01,10:11
r out	Lo 00-11
r out-op	Lo 00-11,Hi 00-11

組み合わせ	OL OH EL EH
00 NOP		xx xx 0  0
01 out W	ww ww 1  1		W
10 our r	dd ss 1  1		dd->Lo,ss->Hi
11 out r	rr xx 1  0		r->Lo

組み合わせ	OL OH EL EH
000 NOP		xx xx 0  0
001 x		xx xx 0  0
010 out W0	00 01 1  1		W0
011 out W1	10 11 1  1		W1
100 our r   dd ss 1  1		dd->Lo,ss->Hi
101 out r	rr xx 1  0		r->Lo
110
111

rrはLoだけに出す場合でもOPCodeの下位、中位から持ってくる場合がある

・RegSelectState
				RI  ROH ROL ROS
			bit	76  54  32  10
000 NOP			00  xx  xx  00	00
001 			00  xx  xx  00	00
010 W OUT		00  11  11  11	3F
011 W in		11  xx  xx  00	C0
100 r out		00  00  10  01	09	r単独で出すだけの場合はSTのみ
101 r in		01  xx  xx  00	40	r単独で入力はLD、MOVIなので、Loからもらう、レジスタはオペコードbit2-3
110 r in-out	01  xx  01  01	45
111 r in-out	10  01  10  11  9B


OPCodeの0-1か2-3か、Hiにどっちを出すか
・state in
				RegInState			RegOutState
000 NOP			000(0)				0						出力disable
001
010 W out		000					01 W
011 W in		11.W(11)
100 r out							10 rr					r out のみの場合。STだけなのでLoに出す
101 r in		rr -> S2.0.S0(01)							OPCodeのbit1-0かbit3-2かはOPCodeで判定する（下位５ビットで判定）
110 r in-out	rr -> S2.0.S0		10 rr下位２ビット		(mov,1op演算など、Src->Lo, dist->Lo)
111 r in-out	rr -> S2.0.S0		11 Lo:b2-3 Hi:b0-1		(算術演算なので、Dist->Lo,Src->Hi, dist->Lo)


110 r in
LD
MOVI
NOT,SHR


RegInState(仮) -> DataRegWriteSelect
S2	S1	S0	O0	O1	O2	O3
0	0	0	0	0	0	0
0	0	1	0	0	0	0
0	1	0	1	0	0	0
0	1	1	0	1	0	0
1	0	0	0	0	1	0
1	0	1	0	0	0	1
1	1	0	1	1	0	0
1	1	1	0	0	1	1

State in -> DataRegInDataSelect
BIt1,3 : S2 and S1 -> 1
other 0

BIT

		0	1	2	3	4	5	6	7	8	9	A	B	C	D
LD
ST


DRegWriteSelect
r0 0001
r1 0010
r2 0100
r3 1000
w0 0011
w1 1100

state
00000  ; OutDisable Latch:no


mov r,r の時はソースをOutDat1(Lo)に出す


InDataSelect:OutSelect1:OutSelectEnable1=1
dst=r0-r3 0
src r0

DRegInDataSerect

OP Out
push/pop W

InData1	入力Lo
InData2	入力Hi
WriteSelect　４bit　どのレジスタに書き込むか。４つ全てに同時に書き込んでもいい。
InDataSelect　４bit　InData1とInData2のどちらを書き込むか。
OutSelect1　２bit　DataBusLo側に出すレジスタ
OutEnable1　出力イネーブル
OutSelect2　２bit　DataBusHi側に出すレジスタ
OutEnable2　出力イネーブル
CLK




リセットは入れてない。

○デコーダ

fetch stage 1 CP->AddressLo/Hi OPRegにもらうので、DREG入力はしない。
	次のクロックでデータバスからOPCodeをもらう
fetch stage 2 データバスからOPCodeをもらう。
	QV00は全て１バイト命令なので、ここでデコードへつっこむ
	次のクロックでデコーダがステートを指定してくる。

decode
	デコーダからstateをもらう


W addr out
B in
rr mov
ww mov
rr op
(SP addr out+SP inc)x2
movi imm fetch


・OutEnableSignal



・LatchEnableSignal
AddrLatchEnable


DataRead/Write



OutDataLo/Hi

AddressLatch

・DataRegister
WriteSelect:4
InDataSelect:4
OutEnable1:1
OutEnable2:1
OutSelect1:2	２本のデータバスの１にどのレジスタを出力するか決める
OutSelect2:2

・Flags
CFClearBit:1	1 if clear
ZFClearBit:1	1 if clear

・JMPcc

CondEstablished
条件が成立した時に１
これをStateControlの最下位ビットとORする。
条件ジャンプは偶数ステートに移行するように設定、成立したら+1


・デコーダROMOUT

○信号コントロール
bit
0 INCDEC_AddressOutEnable
1 EnableBusSelect 00:Disable
2		01:BufferLoOutEnabe 10:BufferHiOutEnable 11:AddrLatch ※Decoderなので１本選んで出力
3 INC/DEC Control
4		0000:CPインクリメント 0001:IN->CP 0010:SPインクリメント 0011:SPデクリメント
5		0100:IN->OUT 0101:IN→SP 0110:INインクリメント 0111:INデクリメント
6 		1001:CP->OUT 1101:SP->OUT 1100:TEMP->OUT
7 OutDataHiLoControl 0:Lo 1:Hi ※外バスに内部バスのHiLoどちらを出力するか
8 BusReadControl  ]
9 BusWriteControl ]この２つは同時にHiにしないようにWriteControlはピンに出てる。両方０の時はピンはreadになる
10 DataRegisterControl
11		000:NOP 001:Undef 010:W OUT 011:W in 100:r out
12		101:r in 110 r:in-out(Lo Only) 111:r in-out
13 BusBufferLo LatchEnable
14 InData(ExternBUS)OutLo/HiSelect 0:Lo 1:Hi
15 ALU-BusSelect(DataRegisterに0:BUS、1:ALUどちらを入力するか)



○デコーダROM
※StateCtrlにSignalCtrlのインデックス＋次のステート、にしたほうがええかな

・OPCodeStateTable
00000 02

・SignalControl			+         +        +    +
						15 14 13 12-10 9-8 7 6-3  2-1 0		Hex		NEXT
00 fetch				0  0  0  000   00  0 0000 11  1		0007	01
01 fetch datain			0  0  0  000   01  0 0100 00  0		0120	OPECodeTbl
02 LD addr				0  0  0  010   00  0 0100 11  1		0827	03
03 LD datain 			0  0  0  101   01  0 0100 00  0		1520	00
04 ST addr				0  0  0  100   01  0 0100 11  1		1127	05
05 ST dataout			0  0  0  100   10  0 0100 00  0		1220	00
06
07
08 MOVI fetch next		0  0  0  101   01  0 0000 11  1		1507	00
09 MOV dd,ss			0  0  0  110   00  0 0100 00  0		1826	00
0A MOVW	W->CP			0  0  0  010   00  0 0001 00  0		0808	00
0B MOVW	W->SP			0  0  0  010   00  0 0101 00  0		0828	00
0C MOVW CP<-W			0  0  0  011   00  0 1001 00  0		0C28	00
0D MOVW SP<-W			0  0  0  011   00  0 1101 00  0		0C38	00
0E
0F
						+         +        +    +
						15 14 13 12-10 9-8 7 6-3  2-1 0		Hex		NEXT
10 PUSH SP--,OUT(W)		0  0  0  000   00  0 0011 11  1		001F	11	//	アドレスラッチ後データ出力なので
11 PUSH DATAOUT	Hi		0  0  0  010   10  1 0100 00  0		0AA0	12	//	上位にHiなので
12 PUSH SP--,OUT		0  0  0  000   00  0 0011 11  1		001F	13
13 PUSH DATAOUT Lo		0  0  0  010   10  0 0100 00  0		0A20	00
14 PUSH SP--,OUT(P)		0  0  0  000   00  0 0011 11  1		001F	15
15 PUSH DATAOUT Hi		0  0  0  000   10  1 1001 00  1		02C9	16
16 PUSH SP--,OUT		0  0  0  000   00  0 0011 11  1		001F	17
17 PUSH DATAOUT Lo		0  0  0  000   10  0 1001 00  1		0249	00
18
19
1A ADDC
1B SUBB
1C NAND
1D XOR
1E
1F

						+         +        +    +
						15 14 13 12-10 9-8 7 6-3  2-1 0		Hex		NEXT
20 POP SPOut(W)			0  0  0  000   00  0 1101 11  1		006F	21
21 POP DIN,SP++,BUF		0  0  1  000   01  0 0010 00  0		2110	22	//	W書き込みは２つめのdatainのとき、ここはバッファにためる
22 POP SPOut			0  0  0  000   00  0 1101 11  1		006F	23
23 POP DIN,SP++,R		0  1  0  011   01  0 0010 00  0		4D10	00
24 POP SPOut(P)			0  0  0  000   00  0 1101 11  1		006F	25
25 POP DIN,SP++			0  0  1  000   01  0 0010 00  0		2110	26
26 POP SPOut			0  0  0  000   00  0 1101 11  1		006F	27
27 POP DIN				0  1  0  000   01  0 0001 00  0		4108	00
28
29
2A INC					0  0  0  010   00  0 0110 00  0		0830	2B	// tempラッチ→バスもらい
2B INC WriteBack
2C DEC
2D
2E
2F

						+         +        +    +
						15 14 13 12-10 9-8 7 6-3  2-1 0		Hex		NEXT
30 JMP
31 JMP CondOk
32 JMP CP++				34
33 JMP CP++,Latch Lo
34 JMP CP++				00
35 JMP addrOut
36
37 JMP CP++,
38
39
3A CALL CP++ latch
3B CALL addrLo->Buff
3C CALL CP++ latch
3D
3E
3F NOP		00

・StateControl
State:5    NextState:5
00000:00001	;	fetch addrout
00001:xxxxx	;	fetch datain　CPINC

3 LD.AddrOut->Latch
5 LD:DataIn
ST:AddrOut->Latch
ST:DataOut->Latch
MOVI r,imm8:FetchOP2 AddrOut
MOVI r,imm8:FetchOP2 DataIn Data->DReg

MOV dd,ss:DataOut/In

MOVW W,SP/CP:DataOut/W In
MOVW SP/CP,W:DataOut/W In


・ExecuteSignalControl



decode_rom
0000 LD/ST
state
000
 dreg -> datareg dreg_select<-

001
 dreg- > addrreg

010
 datain

OE=0

WE=0

PE=WE=1

fetch stage
000
 CP->addrreg
 OE=0 (assert)half-adder

001
 datareg<-data bus
 OE=1

 opreg <- datareg(selector)

ピンアサイン

VCC
GND

ADDR[0..15]
DATA[0..7]
OE
WE

CLK
RST



○引き算
Half-AdderからではなくFull-SubtractorのBorrowがある時0の場合で
それから、それを引き算だと思うのは設計者と動作を見ている人であって、論理回路には引き算を示す抽象概念は存在しないこと

Full-Subtractorでborrowがある時0
1ビット同士の引き算について考える時、筆算に例えて「引けなかったら」
引けないかどうかの判定が必要ないように、最初から上の桁から借りてくる
１ビットの０引く１ビットの１を、１０－１に置き換えて考えることが出来る。
すると、「引けなかったら」について考える必要が無くなる。
真理値表を作る時に入力のBorrowが０という事は、下の桁に貸してしまったと考える。
１ビットの０から下の桁への貸しと引く数と、両方引いた場合でも、考え方が上の桁から借りて来てあるのだから、10-1-1
で、結果は 0 borrow 0 になる。
こうして回路を組んで実際に8ビットの計算が出来るようにすると、負の数は 0-1 を計算してみればわかる。
２の補数表現を発明しなくても自然と導けるのである。

入力のBorrowは、下の桁に貸したかどうかの結果、出力のBorrowは、上の桁からあらかじめ借りた1を使ったかどうか、
思考をシンプルにして、思考から作った真理値表が正しいと、
真理値表はどういう考えで作ったか


○作った
論理回路でプロセッサを設計するのが目標
必要な知識は一通り理解したと思うので、作ってみた。
参考になる文献は色々ありますが、まずは自分で思った通り
動作するまで作ってみて解る事がたくさん
この回路を整理して規模を最小限に
ただし、基本戦略は変えない

もうひとつ、発展させて作り直し



# 心の準備
２つ

１、コンピュータは決める事で成り立つ

２、コンピュータはスイッチの連鎖

コンピュータの動作原理について知る前に、発想の転換というか、心の準備をしないといけない点が２つあります。

１つは、コンピュータはそれが全て決める事で成り立っている事。
２つめは、コンピュータはスイッチのON/OFFの連鎖だけで出来ている事。


加算だけとか（減算だけどか）、引き算が苦手とか、論理演算しか出来ないとか、そういう解説がたくさんあります。
たぶん、苦手なのは解説してる人で、コンピュータには苦手も得意もありません。ただ単に「ON／ＯＦＦの伝達」だけで出来ています。

算数で「１＋１＝２」について考えてみましょう。
数字の１も２も、＋も＝も、それ自身が「私は数字」とか「あ、これ足し算だ！」とか、そうは思っていないでしょう。数字や記号が自分自身で加算の概念を持っているわけではありません。

コンピュータも同じです。
１＋１を入力して２が出てきたとします。この１や＋や２は、入力した人やそれを見た人が、数字だ、加算記号だと思うだけです。
たとえ１＋１を入力して３が出てきたとしても、それを設計・実装した人と、入力した人の期待とが合っていないというだけで、設計したひとがそういう動作だと「決めた」のかもしれなくて、それは間違いではありません。というか、コンピュータにはそもそも「間違っている」という概念を持ち込むべきではありません。

コンピュータはそれが設計・実装した人の決めた通り、作った通りの動作をします。
そしてその「動作」とは、スイッチのＯＮ／ＯＦＦの連鎖だけなのです。
判定とか判断とか、そのようなモノはありません。

私の設計した引き算回路は、それを「引き算」だと思っているのは私で、トランジスタや配線は引き算とは何の関係もありません。中身はトランジスタと配線ですから。
それは、私がそれを「引き算回路として」設計したというだけです。
そして、それを利用した人が「なるほど、引き算だ」と思うだけです。
コンピュータについて知るにあたって、この発想の転換が必要です。
「どういう動作かはヒトが決める」し「それを何なのか考えるのもヒト」だという事を解っておいてください。
そして、コンピュータの動作は、スイッチのＯＮ／ＯＦＦの伝達だけです。


○雑記

そろばんの例



○NAND2Tetris

筆者らが本書を使って授業を行う場合、いつも次の2 点を大切な前提として話を進
めることにしている。ひとつ目は、わかりきった場合を除いて「最適化」については
注意を払わない、ということである。最適化という重要な問題については、他の専門
的な授業に任せることにしている。もうひとつは、変換器（アセンブラ、VM 実装、
コンパイラ）を開発するときには、誤りのないテストファイル（ソースプロブラム）
を提供し、変換器への入力に誤りがないと保証していることである。これによって、
エラーや例外に対処するためのコードを書く必要がなくなり、ソフトウェアの開発が
進めやすくなる。


これは途方もなく複雑な
仕事に相違ない。我々はこの複雑性に対して、プロジェクトをモジュールに分割する
ことで対処する。

・抽象化について




AIの大御所の中島秀之さんのFBで、下記のような議論をしました。


野村 直之 うーん、指数関数、シンギュラリティの意味もわからず、それらのキーワードで有名になろうとした鈴木さんは、大変残念な方ですね。出版社のせいかも知れませんが
いいね！
 · 返信 · 1 · 11月24日 21:25
大岩 元 この人は東大の物理工学科出身ですから、シンギュラリティーはともかく、指数関数は分っているはずです。
いいね！ · 返信 · 昨日 11:03
管理する
野村 直之
野村 直之 いや、疑わしいですね。定義でなく、その意味entailmentがわかっているか？体感intuitionをもてているか？ということです。

カーツワイル氏が、３次関数と指数関数（有限回数でリソースを食い尽くす、垂直上昇といえる関数）の違いをわかっていないのに近いことを、シンギュラリティ経済とやらのご著書のまえがきに書いておられました。「いずれにせよ指数関数的に技術が発達することだけは間違いない」みたいな異常なことを多くの有識者が平気で言うのが信じられません。印刷技術で高密度化ができる半導体がほとんど唯一の例外で、ほぼすべてのITはそれに相乗りしていたわけで、HDDやCPUはすべて多項式関数におさまり、GPUだけが例外としてまだ、指数関数的に性能向上しているというのが現在の状態でしょう
いいね！ · 返信 · 1 · 昨日 11:30 · 編集済み
削除
大岩 元
大岩 元 GPU が指数関数的に成長しているということは、目的を特定したCPU がそうなっているのだと考えられます。今、シリコンバレーでは FPGA で特定目的の CPU を設計して、それをクラウド上で利用することが始まっているそうです。ソフトウェアの設計とハードウェアの設計が一体化して考えられる時代に入りつあるのだと思います。アプリはどんどん広がるので、そうなると、コンピュータシステムの指数関数的な性能向上の可能性がしばらく続くのではないかと思います。不足するのはアルゴリズムの設計者で、ここで成長が律速されると思います。
　微細化による回路の処理能力向上は、もう進まないと思います。寸法が量子力学の領域に入りつつあり、多分信号のＳ／Ｎも下がり、能力向上は期待できないと思います。
いいね！ · 返信 · 1 · 20時間前


This is our italian fork project based on Logisim :)
https://logisim.altervista.org/

PopekとGoldbergの仮想化要件

Microkernels are minimal but highly flexible kernels.
http://www.l4ka.org/

chibiOS
http://www.chibios.org/dokuwiki/doku.php

Hatada's Home Page
デジタル回路
http://home.a00.itscom.net/hatada/_toc/dc.html


NOTとNANDとド・モルガン。
あと真理値表。

ランダムロジックとμコード

○割り込みと8259
https://kuninet.org/2019/03/10/sbc80%e7%b3%bb-%e3%82%b7%e3%83%aa%e3%82%a2%e3%83%ab%e5%85%a5%e5%8a%9b%e3%81%ae2%e7%b3%bb%e7%b5%b1%e5%af%be%e5%bf%9c1/



; Echo back.
00 : 7c 01 0f	mov a0,0f01
loop:
03 : 00			ld r0,[a0]
04 : 49			mov r1,r0
05 : b8			or r0,r0
06 : e5 fb		jz loop
08 : de			dec a0
wait:
09 : 00			ld r0, [a0]
0A : a5 08		and r0, $08
0C : e5 fb		jz wait
0E : d6			inc a0
0F : 09			st[a0],r1
10 : ee f1		jmps loop

00 : 7c 01 0f 00 49 b8 e5 fb de 00 a5 08 e5 fb d6 09
10 : ee f1


 7c 01 0f 00 49 b8 e5 fc de 00 a5 02 e5 fb d6 08 ee f1

 7c 01 0f 00 b8 e5 fc ff 08 ee f8

b0		xor r0,r0
e5 fd	jz -3
ee fe	jmps -2
b0 e5 fd ee fe